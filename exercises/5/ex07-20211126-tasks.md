# Упражнение 7 - Двоични дървета

[код от упражнението](ex07-20211126-solutions.rkt)

## Двоични дървета

За удобство и консистентност ще използваме следните "стандартни" функции за работа с дървета:
```
(define (tree? t)
  (or (null? t)
      (and (list? t)
           (= (length t) 3))
           (tree? (cadr t))
           (tree? (caddr t))))
(define empty-tree '())
(define (make-tree root left right) (list root left right))      ; не искаме просто (define make-tree list) - защо?
(define (make-leaf root) (make-tree root empty-tree empty-tree)) ; за удобство
(define root-tree car)
(define left-tree cadr)
(define right-tree caddr)
(define empty-tree? null?)
```
Примерно дърво:
```
(define test-tree
  (make-tree 10
             (make-tree 7
                        (make-leaf 10)
                        (make-leaf 2))
             (make-tree 3
                        (make-tree 4
                                   (make-leaf 1)
                                   (make-leaf 2))
                        empty-tree)))
```
### Зад.1.
Да се напише функция `(height t)`, която връща височината на дадено дърво - броя върхове в най-дългия път корен-листо.
```
(height empty-tree) -> 0
(height test-tree) -> 4
```
### Зад.2.
Да се напише функция `(get-level n t)`, която връща списък от всички върхове в дървото `t` на дълбочина (разстояние от корена) `n`.
### Зад.3*.
Да се напише функция `(find-longest-path t)`, която връща списък от стойностите във върховете в най-дългия път корен-листо в `t`.
```
(find-longest-path test-tree) -> '(10 3 4 1) ; или '(10 3 4 2), няма значение
```
### Зад.4.
Да се напише функция `(tree-map f t)`, която `map`-ва функцията `f` на всички стойности в дървото `t`.
### Зад.5.
Да се напише функция `(tree->list t)`, която връща списък от всички елементи на дървото, получени при обхождане ляво-корен-дясно.
### Зад.6.
Да се напише функция `(bst-insert val t)`, която вмъква стойността `val` в двоичното наредено дърво `t`.
### Зад.7.
Да се напише функция `(tree-sort lst)`, която сортира списъка `lst`, използвайки предишните две функции.
### Зад.8*.
Да се напише функция `(valid-bst? t)`, която проверява дали дървото `t` е валидно двоично наредено дърво.

_Упътване_: валидно ли е (по същия смисъл) следното дърво? Защо?
```
(make-tree 2
           (make-tree 1
                   empty-tree
                   (make-leaf 3))
           empty-tree)
```
### Зад.9.
Да се напише функция `(prune t)`, която премахва всички листа в дървото `t`.
### Зад.10.
Да се напише функция `(bloom t)`, която заменя всяко листо със стойност `x` със следното дърво:
```
  x
 / \
x   x
```
### Зад.11*
Да се напише функция `(avg t)`, която заменя стойностите във всеки възел на дадено дърво със средно-аритметичното на минималната и максималната стойност в поддървото с корен съответния възел.
### Зад.12*.
Път от корен до възел в двоично дърво кодираме с поредица от цифри 0 и 1, която започва с цифрата 1, а за всяка следваща цифра 0 означава завиване по левия клон, а 1 — по десния. Да се напише функция `(same-as-code t)`, която в двоично дърво от числа връща списък от тези числа `x`, за които стойността на двоичното число, кодиращо пътя от корена до възела на `x`, съвпада с `x`. Подредбата на числата в списъка няма значение.
```
(same-as-code test-tree) -> '(3)
```
