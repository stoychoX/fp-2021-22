# Упражнение 5 – Още списъци и функции от по-висок ред върху тях

[код от упражнението](ex05-20211112-solutions.rkt)

### Зад.1.
Да се напише функция `(uniques lst)`, която оставя само уникалните стойности в даден списък. Можете да проверявате за еднаквост с `equal?` за най-сигурно.
```
(uniques '(1 2 2 "iei" 1 3 "iei" 'oops)) -> '(1 2 "iei" 3 'oops) ; подредбата в резултата няма значение
```
### Зад.2.
Да се напише функция `(insert val lst)`, която вмъква стойността `val` на правилното място в сортирания в ненамаляващ ред списък `lst`:
```
(insert 5 '(1 4 10)) -> '(1 4 5 10)
(insert 12 '(1 4 10)) -> '(1 4 10 12))
```
### Зад.3.
Да се напише функция `(insertion-sort lst)`, която прави точно това, което подсказва името ѝ:
```
(insertion-sort '(4 3 6 2 1 8 10)) -> '(1 2 3 4 6 8 10)
```
### Зад.4.
Да се напише функция `(sublist? needle haystack)`, която проверява дали `needle` e подсписък на `haystack`.

_Упътване:_ използвайте помощна функция `begins-with?`.

### Зад.5*.
Да се напише функция `(group-by f lst)`, която групира елементите на списъка `lst` по стойността, която `f` връща за тях:
```
(group-by even? '(1 2 3 4 5)) -> ((#f (1 3 5))
                                  (#t (2 4))) ; подредбата няма значение
(group-by length '((1 2 3) (4) (5 6 7))) -> '((1 ((4)))
                                              (3 ((1 2 3) (5 6 7))))
```
### Зад.6.
Да се напише функция `(compose-n . fns)`, която приема произволен брой функции като аргументи и връща тяхната композиция:
```
(define (sq x) (* x x))
(define (1+ x) (+ x 1))
(define f (compose-n sq 1+ (lambda (x) (* x 2)) 1+))
; това е екв. на:   (sq
                       (1+
                          ((lambda (x) (* x 2))
                                               (1+ x))))
(f 5) -> 169
```
### Зад.7**.
Да се напише функция `(zipWith* f . lsts)`,  която работи аналогично на `zipWith`, но с произволен брой списъци като аргументи:
```
(zipWith* list '(1 2 3) '(a b) '(7 8 9 10)) -> '((1 a 7) (2 b 8))
(zipWith* + '(1 2 3)) -> '(1 2 3) ; все пак броят списъци е произволен
(zipWith* void) -> '() ; why does this make my head hurt
```
Упътване: можете да подавате аргументи на такъв тип функции с `apply`:
```
(apply + '(2 3 5)) <=> (+ 2 3 5) -> 10
(apply + 1 2 '(3 5)) <=> (+ 1 2 3 5) -> 11
```
## Матрици
За удобство при работа с матрици ще използваме следните "стандартни" интерфейсни функции:
```
(define (head-rows m) (head m))
(define (head-cols m) (map head m))
(define (tail-rows m) (tail m))
(define (tail-cols m) (map tail m))
(define (null-m? m) (or (null? m) (null? (head m))))
```
### Зад.8.
Два реда на матрица наричаме “линейно (не)зависими”, ако елементите на единия ред (не) могат да се получат при умножение на елементите на другия ред с едно и също число. Да се дефинира функция `(dependent? l1 l2)`, която проверява дали списъците от числа с еднаква ненулева дължина `l1` и `l2` са линейно зависими.
```
(dependent? '(2 6 4) '(3 9 6)) → #t
(dependent? '(1 2) '(3 4)) → #f
```
### Зад.8½.
“Псевдоранг” на матрица наричаме максималния брой нейни редове, които два по два са линейно независими. Да се дефинира функция pseudorank m, която пресмята псевдоранга на дадена матрица m от положителни цели числа.

_Упътване 1:_ псевдорангът на матрица, чиито всички n реда са независими, е n.
_Упътване 2:_ псевдорангът на матрица се запазва при премахване на произволен неин ред, който е линейно зависим с някой друг неин ред.
```
(pseudorank '((2 6 4) (6 3 6) (3 9 6) (8 4 8) (1 3 2))) → 2
```
### Зад.9***.
Да се напише функция `(determinant m)`, която намира детерминантата на дадена квадратна матрица `m`.

_Упътване:_ използвайте помощна функция `(gauss row1 row2)`, която прави гаусова елиминация на два реда на матрицата, иначе казано: умножава `row1` и почленно събира с `row2` така, че първият елемент на резултата (промененият `row2`) да е 0:
```
(gauss '(1 -2  0)
       '(2 -3 -6)) → '(0 1 -6)
```
