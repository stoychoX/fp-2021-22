Упражнение 5
============

Задачи - част 1
---------------

1. Да се дефинира функция `length(l)`, която намира броя на елементите на
списъка `l`.

1. Да се дефинира функция `sum(l)`, която намира сумата на елементите на
списъка `l`.

1. Да се дефинира функция `member?(l, x)`, която проверява дали `x` е елемент на
списъка `l`.

1. Да се дефинира функция `last(l)`, която връща последния елемент на списъка
`l`.

1. Да се дефинира функция `nth(l, n)`, която връща елемента на позиция `n`,
броейки от 0, в списъка `l`.

1. Да се дефинира функция `scale(l, x)`, която връща списък с елементите на
списъка `l`, умножени по числото `x`.

1. Да се дефинира функция `reverse(l)`, която връща списък, чиито елементи са
елементите на списъка `l` в обратен ред.

1. Да се дефинира функция `add-last(l, x)`, коята добавя елемент `x` на края на
списъка `l`.

1. Да се дефинира функция `append(l1, l2)`, която конкатенира списъците `l1` и
`l2`.

1. Да се дефинира функция `map(l, f)`, която прилага функцията `f` върху
всеки елемент на списъка `l`.

1. Да се дефинира функция `filter(l, p)`, която връща списък с елементите на
списъка `l`, които удовлетворяват предиката `p`.

1. Напишете процедурата `accumulate`, така че да работи със списъци вместо
интервали от числа.

1. Да се дефинира функцията `(foldl op nv l)`,
която комбинира чрез бинарната операция `op`
всеки от елементите на списъка `l` отляво-надясно
със стойността на акумулатора, чиято начална стойност е `nv`.

    Пример:

    ```scheme
    (foldl + 0 '(1 2 3 4)) ; 10
    ```

1. Да се дефинира функцията `(foldr op nv l)`,
която комбинира чрез бинарната операция `op`
всеки от елементите на списъка `l` **отдясно-наляво**
със стойността на акумулатора, чиято начална стойност е `nv`.

    Пример:

    ```scheme
    (foldr * 1 '(1 2 3 4)) ; 24
    ```

1. Да се дефинира функцията `(foldr1 op l)`,
която комбинира чрез бинарната операция `op`
всеки от елементите на списъка `l` отдясно-наляво
със стойността на акумулатора, чиято начална стойност е някой елемент на `l`.
Списъкът `l` гарантирано има поне един елемент.

    Пример:

    ```scheme
    (foldr1 max '(1 2 33 4)) ; 33
    ```

Задачи - част 2
---------------

1. Да се дефинира функция `maximum(l)`, която
намира най-голямото число в списъка от числа `l`.

2. Да се дефинира функция `remove(l, x)`, която връща нов списък,
в който е премахнато първото срещане на елемента `x` в списъка `l`.

   Например, `(remove '(1 7 3 3 7) 7)` връща `'(1 3 3 7)`.

3. Да се дефинира функция `selection-sort(l)`, която връща списъка `l` сортиран
във възходящ ред чрез метода на пряката селекция. Добавете втори аргумент
`comp`, който е бинарен оператор, който определя реда на сортировката.

   Например, `(selection-sort '(1 2 3 4 5 6 7) >)` връща `'(7 6 5 4 3 2 1)`.

4. Да се дефинира функция `partition(p, l)`, която връща списък от два
подсписъка, където:

   - първият съдържа всички елементи на `l`, които удовлетворяват предиката `p`.
   - вторият съдържа всички останали елементи на `l`.

   Например, `(partition even? '(1 2 3 4 5 6 7))` връща `'((2 4 6) (1 3 5 7))`.

5. Да се дефинира функция `flatten(l)`, която приема списък от _атоми_ (числа)
и _списъци с атоми_ `l` и връща списък с всички атоми.

   Например, `(flatten '((1 2) 3 (4 5) (6 7)))` връща `'(1 2 3 4 5 6 7)`.

6. Да се дефинира функция `map-deep(f, l)`, която прилага функцията `f`
върху всеки атом от всеки вложен списък в списъка `l`.

   Например, `(map-deep square '((1 2 (3 4)) 5))` връща `'((1 4 (9 16)) 25)`.

7. Да се дефинира функция `zip(a, b)`, която чифтосва списъците `a` и `b`
поелементно и връща списък от наредени двойки (a<sub>i</sub>, b<sub>i</sub>),
където a<sub>i</sub> и b<sub>i</sub> са съответно i-тите елементи в `a` и `b`.
Новият списък е с дължината на по-малкия от двата подадени списъка.

   Например, `(zip '(1 3 5) '(2 4 6 8))` връща `'((1 2) (3 4) (5 6))`.

8. Да се дефинира функция `remove-duplicates(l)`, която премахва всички
дубликати в списъка `l` и остава само уникалните елементи.
Нека се запази първото (най-лявото) срещане на дублиран елемент.

   Например, `(remove-duplicates '(4 3 3 2 5 2))` връща `'(4 3 2 5)`.

1. Да се дефинира функция `chunk(l, n)`, която разбива списъка `l` на
подсписъци с дължина `n`.
Последният подсписък може да е с дължина по-малка от n, ако дължината на `l`
не е кратна на `n`.

   Например, `(chunk '(1 1 1 2 2 2 3 4) 3)` връща `'((1 1 1) (2 2 2) (3 4))`.
