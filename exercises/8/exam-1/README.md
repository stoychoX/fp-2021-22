Задачи за подготовка за Контролно 1
===================================

1. `[lists]` Нека `А` и `B` са множества, представени чрез списъци. Да се имплементират следните функции над множествата `А` и `B`:
    - сечение
    - обединение
    - разлика

1. `[HOFs, lists]` Напишете функция от по-висок ред, която по дадена едноместна числова функция `f` и списък от числа `l` намира списък от всички числа `x` в `l`, за които `f(x)` е елемент на `l`.

1. `[digits, recursion, iteration]` Да се напише функция `middle-digit`, която намира средната цифра от записа на подадено естествено число `n`. Ако `n` е с четен брой цифри, функцията връща `-1`.

    Пример: `(middle-digit 452)` → `5`

    Пример: `(middle-digit 4712)` → `-1`

1. `[matrices]` Да се напише функция count-cols, която приема матрица от числа и намира броя на колоните, в които има поне едно число, което съвпада със сумата на останалите числа в колоната.

    Пример: `(count-cols '((1 2 3 6) (2 3 4 2) (3 4 5 4)))` → `2`

1. `[matrices]` Да се напише функция `two-rows?`, която приема матрица от числа и проверява дали в нея има два реда, такива че всички числа от първия ред са по-малки от всички числа във втория ред.

    Пример: `(two-rows? '((1 2 3) (2 3 4) (3 4 5) (6 5 4)))` → `#t`

1. `[HOFs, lists]` Нека е даден списък l от числа и двуместна операция над числа ⊕. Функцията f наричаме “ендоморфизъм над l”, ако f трансформира l в себе си, запазвайки операцията ⊕, т.е. `∀x∈l f(x)∈l` и `∀x,y∈l f(x) ⊕ f(y) = f(x ⊕ y)`. Да се реализира функция `is-em?`, която проверява дали `f` е ендоморфизъм.

    Пример: `(is-em? '(0 1 4 6) + (lambda (x) (remainder x 3)))` → `#t`

1. `[HOFs, lists]` Нека са дадени два списъка от числа `l1` и `l2`.
Функцията `f` наричаме *"сюрекция от l1 в l2"*, ако:
    - `f` трансформира `l1` в `l2`:  `∀x∈l₁ f(x)∈l₂`
    - `f` покрива изцяло `l2`: `∀y∈l₂ ∃x∈l₁ f(x)=y`

    Да се напише функция `is-sur?`, която проверява дали `f` е сюрекция.

    Пример: `(is-sur? '(0 1 -1 2) '(0 1 4) square)` → `#t`

1. `[trees]` В дадено двоично дърво "семейство" наричаме даден възел заедно с неговите деца. Казваме, че две семейства "си приличат", ако съвпадат по структура и стойности на съответните им възли. Да се напише функция `families-alike?`, която проверява дали в дадено двоично дърво има приличащи си семейства.

1. `[trees]` В дадено двоично дърво казваме, че два възела са "братовчеди", ако общият родител на двамата е поне две нива над тях. Да се напише функция "cousins", която по дадено двоично дърво от различни числа и възел `u` в него намира броя на всички братовчеди на `u`. Представянето на дървото е по ваш избор.

1. `[graphs]` Да се напише функция `(chinese? g)`, която за даден граф g
проверява дали за него е изпълнен китайският закон: *"даден възел може да има повече от един наследник само ако е той е единствен наследник на родителя си"*.

1. `[digits, recursion, iteration]` Да се напише процедура `(diff-reverse n)`, която по дадено естествено
число `n` намира разликата между `n` и числото, записано със същите цифри
като `n`, но в обратен ред. Пример:

    ```scheme
    (diff-reverse 7641) ; -> 6174 (= 7641 – 1467)
    ```

1. `[digits, recursion, iteration]` Да се напише процедура `(sort-digits n)`, която по дадено естествено число
`n` намира числото, записано със същите цифри като `n`, но в монотонно
намаляващ ред.

    Упътване: Възползвайте се, че цифрите са само 10 на брой и за всяка от тях
    можете да преброите колко пъти се среща в `n`.

    Пример:

    ```scheme
    (sort-digits 6174) ; -> 7641
    ```

1. `[HOFs]` Да се напише процедура `(permutable? a b f g)`, която по дадени две
естествени числа `a` и `b` и две едноместни числови функции `f` и `g` проверява
дали за всички четни числа `x` в интервала [`a`, `b`] е изпълнено, че
`f(g(...f(g(x))...)) = g(f(...g(f(x))...))`, където общият брой прилагания на
функции от всяка страна на равенството е `x`. Пример:

   ```scheme
   (permutable? 1 9 (lambda (x) (* x x)) (lambda (x) (* x x x))) ; -> #t
   ```

1. `[lists, pairs]` Отворен числов интервал (a, b) се описва с наредената двойка `(a . b)`.

    a) Да се напише процедура `(longest-interval-subsets il)`, която по даден списък от
    интервали `il` връща нов списък, който съдържа всички интервали от `il`, които
    са подинтервали на най-дългия интервал в списъка.

    б) Процедурата `longest-interval-subsets` да връща подинтервалите подредени в
    нарастващ ред по началната си точка. Пример:

    ```scheme
    (longest-interval-subsets '((24 . 25)
                               (90 . 110)
                               (0 . 100)
                               (10 . 109)
                               (1 . 3)
                               (-4 . 2))) ; -> ((0 . 100) (1 . 3) (24 . 25))
    ```

    в) Да се напише процедура `(shortest-interval-supersets il)`, която по даден списък
    от интервали `il` връща нов списък, който съдържа всички интервали от `il`, на
    които най-късия интервал в списъка е подинтервал.

    г) Процедурата `shortest-interval-supersets` да връща  подинтервалите
    подредени в нарастващ ред по крайната си точка. Пример:

      ```scheme
      (shortest-interval-supersets '((24 . 26)
                                     (90 . 110)
                                     (0 . 100)
                                     (10 . 89)
                                     (1 . 5)
                                     (-4 . 25))) ; -> ((24 .  26) (10 . 89) (0 . 100))
      ```

1. Казваме, че дадено `n`-цифрено число е нарцистично, ако то съвпада със
сумата от `n`-тите степени на цифрите си. Да се напише процедура
`(narcissistic? n)`, която проверява дали дадено число `n` е нарцистично.

    Пример:

    ```scheme
    (narcissistic? 153) ; -> #t (= 1³ + 5³ + 3³)
    ```

1. С `d(x)` означаваме сумата на делителите на естественото число `x`, които са
различни от самото `x`. Две естествени числа `a` и `b` наричаме приятелски, ако
`d(a) = b` и `d(b) = a`.

    Да се напише функция `(friendly? a b)`, която проверява
    дали две дадени числа `a` и `b` са приятелски.

    Пример:

    ```scheme
    (friendly? 220 284) ; -> #t
    ```

1. Да се напише процедура `(find-max f a b)`, която по дадена двуместна числова
функция `f` и цели числа `a` и `b` намира най-голямата стойност от вида
`f(i, f(i+1, … f(j-1, j))` за `a` ≤ i < j ≤ `b`. Пример:

   ```scheme
   (find-max - 1 5) ; -> 4 (= 3 - (4 - 5))
   ```
