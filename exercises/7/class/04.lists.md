# Списъци 

## Quiz time

```scheme
((if ((lambda (x) (not x)) (= (string-length "abc" 4))) (lambda (x) (+ x 1)) (lambda (x) (+ x 2))) 9)

(let ((a (lambda (x) (+ x 3)))
      (b 10)
      (c (a b)))
  c
)
```

[Може да четем и от тук](https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_sec_2.1)

За какво ще става дума долу:
1. Какво са двойките и какви проблеми решават
2. Пример с реализиране на рационални числа
3. Пример за реализация на двойки
4. Какво са списъците и какви проблеми решават
5. Задачи за упражнение

## 1. Какво са двойките и какви проблеми решават?

До този момент създавахме абстракции на база функции. Данните, които манипулирахме в програмите
се ограничаваха до няколко типа - числа, булеви стойности и функции.

Двойките (pairs) са съставен тип данни в езика Scheme, който е нищо повече от два обекта "залепени" заедно.

```Racket
; Конструктор - cons
; x има за стойност двойката (1 . 2)
(define x (cons 1 2))

(define y (cons 3 4))

; Пример за двойка, която има за свои елементи други двойки
; z има за стойност двойката ((1 . 2) . (3 . 4))
(define z (cons x y))

; Селектор, връщащ първия елемент на двойка - car
(car x) -> 1
(cdr y) -> 4

; Как да вземем числото 3 от z?
(car (cdr z)) -> 3
; Защото (cdr z) -> (3 . 4)
; (car (3 . 4)) -> 3
```

## 2. Реализиране на рационални числа

Готови сме за първия си абстрактен тип данни в Scheme.  
Какво трябва да можем да правим с рационални числа?
* Да ги създаваме
* Да достъпваме числителя
* Да достъпваме знаменателя
* Да извършваме някакви операции между тях
* Да ги съкращаваме

Създаването на рационално число ще е просто слагането на числител и знаменател в двойка.  
Първият елемент на двойката означава числител, а втория - знаменател.

```Racket
(define (make-rational num denom)
  (cons num denom)
)
```

Достъпването на числителя и знаменателя се случва с гореспоменатите функции `car` и `cdr`

```Racket
(define (numerator number)
  (car number)
)

(define (denominator number)
  (cdr number)
)
```

Някаквите операции:
```Racket
(define (sum-rationals first second)
  (/ (+ (* (numerator first) (denominator second))
        (* (numerator second) (denominator first)))
     (* (denominator first) (denominator second))
  )
)

(define (subtract-rationals first second)
  (/ (- (* (numerator first) (denominator second))
        (* (numerator second) (denominator first)))
     (* (denominator first) (denominator second))
  )
)

(define (mult-rationals first second)
  (/ (* (numerator first) (numerator second))
     (* (denominator first) (denominator second))
  )
)

(define (div-rationals first second)
  (/ (* (numerator first) (denominator second))
     (* (numerator second) (denominator first))
  )
)
```

Примерна работа с такива числа:
```Racket
(define rational-pi (make-rational 22 7))

(define random-number (make-rational 1 3))

(numerator rational-pi) -> 22

(denominator random-number) -> 3

(mult-rationals rational-pi random-number) -> 22/21
```

## 3. Примерна реализация на двойки

Функциите за работа с двойки са вградени в езика. Въпреки това си струва да видим как ние можем да ги реализираме със знанията си до тук.

Функциите `cons`, `car` и `cdr` трябва да удовлетворяват следните условия:
* Ако сме 'залепили' два обекта с `cons`, то `car` трябва да върне първия от тях
* Ако сме 'залепили' два обекта с `cons`, то `cdr` трябва да върне втория от тях.

Тоест: Ако `z` e `(cons x y)`, то `(car z)` трябва да бъде `х`, а `(cdr z)` - `y`.

```Racket
(define (cons x y)
  (lambda (m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else (error "Undefined behavior for cons"))
    )
  )
)

(define (car z) (z 0))

(define (cdr z) (z 1))

(define z (cons 6 7))
; z вече е едноаргументна функция (според cons горе).
(car z) -> 6
; Извиквайки car на z, ще извикаме z с аргумент 0 и това ще ни върне 6.
```

**Още една примерна реализация:**

```Racket
(define (cons x y)
  (lambda (m) (m x y)))

(define (car z)
  (z (lambda (p q) p)))
```

Отговорете си на въпроса защо са валидни.  
Напишете `cdr` по такъв начин.

## Списъци

Списъците в Scheme се ограждат в скоби. Стойностите се разделят с интервал.
```Racket
(1 2 3 4)
(#t #f #f #f #f #t)
(2 #t (lambda (x) (+ 2 x)) 12 3.5)
```

 Тези неща обаче изглеждат точно като прилагания на функции.  
 Всъщност е наобратно: **Прилаганията на функции са списъци.**   
 `(expt 2 3)`, `(define a 12)`, `(lambda (x) (+ 2 x))` са списъци.  

 Обикновено, когато дадем проста стойност на интерпретатора, той я оценява и ни връща резултат. Например:
 ```Racket
> 2
2
> #t
#t
 ```
 Ако му дадем обаче `(1 2 3 4)`, той ще се оплаче, че не може да приложи функцията `1` върху аргументи `2 3 4`. Това е така заради правилато за оценяване на функции. Първо се оценява първия елемент на списъка (като оператор), а след това останалите елементи (като операнди).  

 В езика е вградена специалната форма `quote`, която потиска оценяването на израз. Има съкратен запис на `quote` - `'`. Примери:
 ```Racket
> (1 2 3 4)
<Мрън, не мога да приложа функцията 1 към аргументи 2 3 и 4>

> '(1 2 3 4)
'(1 2 3 4)
 ```

 Какъв е смисълът на `quote`? Нека имаме следните два диалога:
 ```
- Кажи ми името си!
- Харалампи.

- Кажи ми "името си"!
- Името си.
 ```

 Същата е и разликата между `(1 2 3 4)` и `'(1 2 3 4)` в Scheme.

Списъците в Scheme ще разглеждаме като поредица от двойки.  
Първата част на всяка двойка съдържа текущия елемент от списъка, а втората - следващата двойка от списъка.  


![Representing lists as pairs](https://mitpress.mit.edu/sicp/full-text/book/ch2-Z-G-13.gif)

Горният списък можем да изградим по няколко начина:
```Racket
; Начин 1 - поредица от вложени двойки
(cons 1 (cons 2 (cons 3 (cons 4 '()))))

; Начин 2 - използване на конструктор за списък - list
(list 1 2 3 4) ; Превежда се до Начин 1

; Начин 3 - използване на литерал
'(1 2 3 4)
```   

```Racket
(define my-list (cons 1 (cons 2 (cons 3 (cons 4 '())))))

(car my-list) -> 1
(cdr my-list) -> '(2 3 4)

(car (cdr my-list)) -> 2

(cdr (cdr my-list)) -> '(3 4)
```

Полезнотии за работа със списъци:
* `null?` - предикат, който ни казва дали списък е празен
* `list?` - предикат, който ни казва дали нещо е списък
* `cadr` - еквивалентно на (car (cdr ))
* `(cons x lst)` - залепя `x` в началото на `lst`
* `'()` - празен списък.
