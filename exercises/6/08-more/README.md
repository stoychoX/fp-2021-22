# Още графи, дървета, потоци и др. (упр 8)

1. Да се напише функция (triangular? m), която проверява дали дадена матрица е горно-триъгълна (всички елементи под главния диагонал са нули):
   ```scheme
   (triangular? '((1 2 3 4)
                  (0 5 6 7)
                  (0 0 8 9)
                  (0 0 0 1))) -> #t
   ```

1. Нека е дадена квадратна матрица от числа. Под “Гаусова елиминация” ще разбираме операцията, при която се избира първият ред отгоре надолу, в който първият елемент е ненулев, и към всеки друг ред на матрицата прибавяме избрания ред, умножен по такъв коефициент, че числата в първия стълб на тези редове да станат равни на нула:
   ```scheme
   '(( 0 3 5 0)      '((0  3 5 0)
     ( 1 5 2 1)   ->   (1  5 2 1)
     ( 2 3 8 4)        (0 -7 4 2)  ; получено от (ред2 * (-2)) + ред2
     (-2 0 4 5))       (0 10 8 7)) ; получено от (ред2 * 2) + ред3
   ```
   Напишете функция row-reduce, която извършва тази операция. Можете да допуснете, че в първия стълб на матрицата има поне един ненулев елемент.

1. (трудна) Напишете функция, която изчислява детерминантата на дадена квадратна матрица.

1.  Да се напише функция (descartes lst1 lst2), която намира декартовото произведение на два списъка - наредените двойки от всеки елемент на единия списък със всеки елемент на другия. Последователността на елементите в резултата няма значение.
    ```scheme
    (descartes '(1 2 3) '(a b)) -> ((1 . a) (2 . a) (3 . a)
                                    (1 . b) (2 . b) (3 . b)) ; или друга тяхна пермутация
    ```

1. Да се напише функция intervalTree, която преобразува двоично дърво от числа в ново дърво със същата структура, в което стойността във всеки възел е заменена с наредена двойка, представляваща най-малкия интервал, съдържащ всички стойности в съответното поддърво.
   ```scheme
   (intervalTree '(5 (3 (1 ()
                           (2 () ()))
                        (4 () ()))
                     (6 () ())))
   ->
   '((1 . 6) ((1 . 4) ((1 . 2) ()
                               ((2 . 2) () ()))
                      ((4 . 4) () ()))
             ((6 . 6) () ())))
   ```

   Бонус: intervalTree да работи за време O(n) в най-лошия случай.

1. Да се генерира поток sumsOfCubes от тези числа, които са сума от кубовете на две положителни цели числа.

1. Да се напише функция inc-stream, която връща безкраен поток от безкрайни потоци от числа. На i-та позиция (i >= 0) в резултата от функцията има безкраен поток от кратните на i + 1 числа:
   ```scheme
   (stream-ref (hw31) 0) -> 1, 2, 3, 4, 5, ...
   (stream-ref (hw31) 1) -> 2, 4, 6, 8, 10, ...
   (stream-ref (hw31) 2) -> 3, 6, 9, 12, 15, ...
   ```
1. Да се напише функция, generateExponents, която по дадени различни естествени числа k и l, генерира безкрайния поток от всички числа от вида x^k * y^l, без повторения и подредени в нарастващ ред.

   Пример: `generateExponents 2 3 → [1, 4, 8, 9, 16, 25, 27, ... ]`

1. Път от корен до възел в двоично дърво кодираме с поредица от цифри 0 и 1, която започва с цифрата 1, а за всяка следваща цифра 0 означава завиване по левия клон, а 1 — по десния. Да се реализира функция sameAsCode, която в двоично дърво от числа връща такова число x, което съвпада по стойност с двоичното число, кодиращо пътя от корена до x, или 0, ако такова число няма. Представянето на дървото е по ваш избор.

   Пример: `(sameAsCode '(5 (3 () (2 () ())) (4 (6 () ()) ()))) → 6`

1. Да се напише функция findGrandsons t, която за дадено двоично дърво от цели числа t намира списък от всички числа, които се делят на дядо си, но не и на баща си.

1. Да се напише функция, която приема като параметър списък от списъци и го сортира по честотата, с която се срещат дължините на вътрешните списъци: lfsort ["abc", "de", "fgh", "fp", "ijkl", "mn", "o"] → ["ijkl", "o", "abc", "fgh", "fp", "de", "mn"] – има един списък с дължина 4, един списък с дължина 1, два списъка с дължина 3 и три списъка с дължина 2. Наредбата между вътрешните списъци, които са “еквивалентни” в този смисъл – т.е.  техните дължини се срещат еднакъв брой пъти – няма значение.

   Упътване: можете да напишете и използвате помощна функция histogram, която приема един списък с произволни елементи и изгражда списък от наредени двойки с всеки негов елемент и броя срещания в списъка: histogram [1,2,2,3,4,2,1,2] → [(1,2), (2,4), (3,1), (4,1)]

1. Нека  е  даден  ориентиран  граф  със символи  по  върховете  и  целочислени  тегла  по  върховете,  който  е представен чрез списъци от наследници по следния начин:

   Scheme:
   ```scheme
   (define G '((a 2 b c)))
               (b 4 a c)))
               (c 1 a b))))
   ```
   Haskell:
   ```hs
   g :: [(Char,Int,[Char])]
   g = [('a', 2, "bc"]),
        ('b', 4, "ac"),
        ('c', 1, "ab")]
   ```
   Да се напише функция  eulerCycleCost, която проверява дали графът съдържа Ойлеров цикъл и ако да, връща цената му (сборът от теглата на върховете, през които минава). Ако Ойлеров цикъл няма, да се върне 0.

1. Да се напише функция  grow t x, която по дадено двоично дърво от числа t получава ново, в което към всяко листо на t добавя по две нови листа със зададена стойност x.

   Двоично дърво наричаме “пълно”, ако има 2n елемента на ниво n. Да се напише функция  growingTrees, която генерира безкраен поток от пълни дървета с височини съответно 1, 2, 3,..., като всички елементи на ниво n са със стойност n.
