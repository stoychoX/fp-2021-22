; Това е коментар

; Default IDE: DrRacket

; racket != r5rs
#lang racket

; Примитивни типове (константи):
;
; Булеви стойности
#t
#f
; Числа
5
-5
1/3
1+6i
; Символ
#\a
; Символен низ
"asdf"

; Функциите се прилагат в префиксна форма.
; (<name> <arg1> <arg2> ..)
; Винаги са оградени със скоби, като винаги първо е функцията.
; Всички елементи в списъка се оценяват последователно до някаква стойност,
; за да се изчисли крайния резултат.
(+ 1 2)
; Конструкции които се оценяват по различен начин се наричат специални форми.

; По-слижни изрази - комбинации
(+ 2
   (/ 10 5)
   (* 1 2 3))

; Сравнение
(equal? 0.5 1/2) ;#f
(= 0.5 1/2) ;#t
; на кратко:
; = работи само за числа и сравнява стоностите
; equal? може да го ползваме за други типове и е по-стриктно


; Ето някои вградени функции:
; *, +, -, /
; Заб: горните работят върху произволен брой аргументи
; remainder, quotient, max, min, gcd, lcm
; floor, ceiling, round
; exp, expt, sqrt, log, sin, cos, tan, asin, acos, atan
; <, >, =, <=, >=
; zero?, negative?, positive?, even?, odd?
; boolean?, number?, char?, string?, symbol?, procedure?
; eq?, eqv?, equal?

; Гледайте документацията за справка.


; Стила за идентация, който аз ще следвам е:
; - При разбиване на извикване на функция на няколко реда,
;   ще изнасям аргументите на нови редове - еднакво идентирани навътре
;   (по-навътре от самата функция)
; - горното правило се прилага за вложени извиквания
; - скобите се затварят зад последния аргумент от извикването

; Специална форма за дефиниция на символи (придаване на стойност).
(define x 2)
; Можем да свързваме символи и с функции.
(define plus +)
(plus 5 2)

; Можем да дефинираме и функции.
; (define
;   (<name> <arg1> <arg2> ..)
;   <body>)
(define (square x) (* x x))
; По конвенция функциите, връщащи булеви стойности, се именуват с "?" в края.
(define (is-positive? x) (> x 0))

; if е специална форма и е израз.
; Можем да го свържем със символ.
; (if <cond> <then-value> <else-value>)
; Условието е #t ако не е #f
(define one-eq-two?
    (if (= 1 2)
      (/ 3 0)
      "Dodged a bullet there"))

; cond е друг условен израз и също е специална форма,
; защото условията се оценяват последователно.
; Може и без else.
(define (abs x)
  (cond [(< x 0) (- x)]
        [(= x 0) 0]
        [else x]))
; Заб: синтаксиса с [] е по-приятен според мен за такива конструкции,
;      но в R5RS не се поддържа

; булевите операции and и or също са специални форми.
(define div (or #t (/ 2 0)))


;;;;;;;;;;
; ЗАДАЧИ ;
;;;;;;;;;;

; void е функция която не прави нищо, удобно е да ви правя предварително
; дефинициите и вие на мястото на void да напишете имплементация.
; void не е част от R5RS

; 1. За дадено естествено число n намира n+1.
(define (succ n) void)

; 2. За дадено естествено число n намира n-1.
(define (pred n) void)

; 3. За дадено число n, връща n/2 ако n е четно, и n в противен случай.
(define (safe-div n) void)

; 4. За дадено x проверява дали е корен на (3*x^2 - 2*x - 1).
; Полинома не се променя.
; Корени: -1/3, 1
(define (is-root? n) void)

; 5. Намира n!.
(define (factorial n) void)

; 6. Намира n-тото число на Фибоначи.
(define (fib n) void)

; 7. Намира сумата на 2 естествени числа, използвайте succ и pred.
(define (add n m) void)

; 8. Намира произведението на 2 естествени числа.
; Използвайте add и pred.
(define (multiply n m) void)

; 9. Намира броя на цифрите на дадено естествено число n.
(define (count-digits n) void)

; 10. За дадени цяло число x и естествено число n връща x^n.
(define (pow x n) void)

; 11. За дадени числа a и b намира сумата на целите числа в интервала [a,b].
; Нека a < b.
(define (interval-sum a b) void)
