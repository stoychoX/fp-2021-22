#lang racket

; Предния път работихме със списъци
; и една функция на много аргументи - accumulate.
; Тя работи върху интервал от числа.
; Сега ще погледнем 2 функции със сходна идея, но върху списъци.

(foldr + 0 '(1 2 3 4)) ; 10
(foldl + 0 '(1 2 3 4)) ; 10
; Каква е разликата тогава?
; foldr сгъва списъка надясно
; С конкретния пример изглежда така:
; (+ 1 (+ 2 (+ 3 (+ 4 0))))
; foldr генерира линеен рекурсивен процес и тези операции са отложени
; т.е. можете да се възползвате от това,
; ако искате операциите ви да се изпълнят в обратен ред

; foldl сгъва списъка наляво
; С конкретния пример сметката би изглеждала така:
; (+ (+ (+ (+ 0 1) 2) 3) 4)
; foldl генерира линеен итеративен процес и тези сметки се случват в аргумента
; на функцията при рекурсивното извикване (опашкова рекурсия)
; NOTE: foldl в racket работи малко по-различно, в конкретния пример:
;       (+ 4 (+ 3 (+ 2 (+ 1 0))))
;       Тоест реда на аргументите на операцията е същия както при foldr
; В Haskell foldl е с обратна на foldr операция

; Също така операцията е с разменени аргументи в двата случая.
; Т.е. при некомутативна операция също би имало разлика кое използвате.

; (foldr / 1 '(1 2 3 4)) -> 3/8
; (foldl / 1 '(1 2 3 4)) -> 1/24

; Това в racket се различава, заради реда на аргументите на операцията
; (foldl / 1 '(1 2 3 4)) -> 8/3


; take и drop са доста полезни функции, но са от racket/list.
; Тoест ги няма в r5rs.

; Връща подсписък с първите n елемента
(take '(1 2 3 4 5) 2) ; '(1 2)

; Връща подсписък без първите n елемента
(drop '(1 2 3 4 5) 2) ; '(3 4 5)


; Знаем че има функции в scheme, които могат да приемат
; произволен брой аргументи: +, *, -, /, and, or ...

; map с произволен брой аргументи
(map + '(1 2 3) '(4 5 6)) ; '(5 7 9)
; списъците трябва да имат еднаква дължина

; apply прилага функция над списък от аргументи
(apply + '(1 2 3 4 5)) ; 15
(apply max '(1 2 3 11 4 5)) ; 11

; apply има вида: (apply proc v1..vn lst kw-arg ...)
; Засега няма да се интересуваме от последните аргументи kw-arg
; Освен подадения списък обаче, apply може да приема и допълнителни аргументи
; (онези v-та)

; Ето тук 2 е допълнителен аргумент към *
(apply * 2 '(1 2 3)) ; 12
; същото като (* 2 1 2 3)

(apply map + '((1 2 3) (4 5 6))) ; '(5 7 9)
; Тук + е допълнителен аргумент към map и затова apply работи нормално.
; Горното се свежда до:
(map + '(1 2 3) '(4 5 6)) ; т.е. map на повече аргументи

; Можем да правим функции на произволен брой аргументи
; (lambda (<args> . <args-list>) <body>)
; Където на мястото на args са изброени задължителните параметри,
; а args-list е списък с опционални параметри.
(lambda (x . lst) (- x (apply + lst)))

; define за функции всъщност е синтактична захар за свързване на име с ламбда.
(define (id x) x)
; е същото като:
; (define id (lambda (x) x))

; Тоест можем да правим и така
(define (sum . l) (foldl + 0 l))


;;;;;;;;;;
; ЗАДАЧИ ;
;;;;;;;;;;

; 1. Връща списъка lst само с първите n елемента.
(define (take* lst n) void)

; 2. Връща списъка lst без първите n елемента.
(define (drop* lst n) void)

; 3. Свива lst наляво с операцията op и начална стойност acc (акумулатор).
(define (foldl* op acc lst) void)

; 4. Свива lst надясно с операцията op и начална стойност acc (акумулатор).
(define (foldr* op acc lst) void)

; 5. Намира дължина на списък. Реализирайте я чрез foldl или foldr.
(define (length* lst) void)

; 6. Връща списък с елементите на lst, но в обратен ред.
;    Реализирайте я чрез foldl.
;    Hint: Спомнете си как cons-овете могат да се изпълнят в обратен.
;          (както като писахме append)
(define (reverse* lst) void)

; 7. Намира броя на елементите в дълбокия списък lst. Тоест lst може да има
;    произволни нива на вложеност.
;    Реализирайте я чрез foldl/foldr
(define (count-atoms lst) void)

; 8. За дадена матрица m връща транспонираната матрица. Матрицата е представена
;    като списък от редове. Всеки ред е списък от елементи.
(define (transpose m) void)

; NOTE: transpose чрез apply?
