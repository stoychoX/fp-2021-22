#lang racket

; НАРЕДЕНИ ДВОЙКИ
; cons създава наредена 2-ка
(cons 1 #\a) ; '(1 . #\a)
; Тук точката индикира че това е наредена 2-ка, а не списък
(list 1 2 3 4) ; в списъка няма точка

(define pair (cons "head" "tail"))

; Имаме предикати, които проверяват дали дадена стойност е от конкретен тип.
; Има такъв и за наредените двойки.
(pair? pair) ; #t


; Функции с които достъпваме елементите на наредена двойка.

; Първия елемент (Contents of the Address Register)
(car pair)   ; "hello"

; Втория елемент (Contents of the Data Register)
(cdr pair)   ; "world"


; СРАВНЕНИЯ
; (= a b) работи само за числа

; (eq? a b) проверява дали a и b са един и същ обект
; (на едно и също място в паметта)

; (eqv? a b) същото като eq? с изключение за някои типове, като char и integer.
; Т.е. за тези типове eqv? дава различен резултат от eq?.

; (equal? a b) същото като eqv? с изключение за много типове.
; Работи за списъци и и може да сравнява покомпонентно.


; СПИСЪЦИ
; 1. '() е списък
; 2. (head . tail) е списък <=> tail е списък

(list 1 2 3 4) ; построява списък от подадените аргументи
; може и с quote
'(1 2 3 4)
; може и с quote - буквално
(quote (1 2 3 4))

; Каква е разликата обаче дали ползваме list или quote,
; за да конструираме списък.

; quote е специална форма и не оценява аргументите си,
; а се прилага "рекурсивно" върху тях
'(1 2 3)
; е същото като
(list '1 '2 '3)

; съответно може да видите разлика, ако в примера има какво да се оцени
'(+ 1 2)      ; тук + е само символ (символ /= char, по скоро immutable string)
(list + 1 2)  ; тук + е процедура
; или ако на мястото на някой елемент сложим променлива
; quote ще вземе буквално името й като символ, а list ще я оцени

'(1 . (2 . (3 . (4 . 5))))  ; '(1 2 3 4 . 5) - наредена 2ка
'(1 . (2 . (3 . (4 . ())))) ; '(1 2 3 4) - списък (и наредена 2-ка)

(pair? '()) ; #f
(list? '()) ; #t
(null? '()) ; #t
; null? e доста удобно

(define deep-list
  '((1 2)
    ((3 4) 5)))
; има съкратен синтаксис за комбиниране на car и cdr
; caar - първия елемент на първия елемент
; cdar - втория елемент на първия елемент
; и т.н.
; Може да ги четете отзад напред за по-лесно
(caar deep-list)  ; 1
(cdar deep-list)  ; (2)


;;;;;;;;;;
; ЗАДАЧИ ;
;;;;;;;;;;

; NOTE: Суфикса * е защото съществуват вградени процедури със същите имена.

; 1. Намира дължината на списъка lst.
(define (length* lst) void)

; 2. Намира сумата на елементите на списъка lst. Предполага се че са само числа.
(define (sum lst) void)

; 3. Връща последния елемент на списъка lst.
(define (last* lst) void)

; 4. Връща n-тия елемент на списъка lst.
(define (nth n lst) void)

; 5. Връща конкатенацията на lst1 и lst2.
(define (concat lst1 lst2) void)

; 6. Прилага fn над елементите на lst, връща новия списък.
(define (map* fn lst) void)

; 7. Връща списък от елементите на lst, за които предиката p е верен
(define (filter* p lst) void)

; 8. Връща списък от 2 елемента - списъци
;   - Елементите от lst изпълняващи предиката p
;   - Останалите елементи на lst
(define (partition* p lst) void)

; NOTE: Вградената функция partition работи малко по-различно
;       - връща (values lst1 lst2)


; ---------------------
; ЗАДАЧИ ОТ МИНАЛИЯ ПЪТ

; 1*. Напишете функция която комбинира числата в даден интервал [from, to]
; с дадена бинарна операция op,
; като преди това върху всяко число прилага дадена едноаргументна функция term
; Пример: сума, произведение, дизюнкция и т.н.
(define (accumulate from to op term acc) void)

; 2. Реализирайте факториел чрез accumulate.
(define (fact n) void)

; 3. Намира броя на числата в интервал, които изпълняват даден предикат.
; Реализирайте я чрез accumulate.
(define (count-p from to p) void)

; 4. Проверява дали даден предикат е верен за всички числа в даден интервал.
; Реализирайте я чрез accumulate.
(define (for-all? from to p) void)

; 5 .Тя проверява дали някое число в даден интервал изпълнява даден предикат.
; Реализирайте я чрез accumulate.
(define (exists? from to p) void)
